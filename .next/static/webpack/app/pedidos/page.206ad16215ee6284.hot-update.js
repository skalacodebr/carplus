"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/pedidos/page",{

/***/ "(app-pages-browser)/./lib/database.ts":
/*!*************************!*\
  !*** ./lib/database.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adicionarItemCarrinho: () => (/* binding */ adicionarItemCarrinho),\n/* harmony export */   atualizarCarrinhoUsuario: () => (/* binding */ atualizarCarrinhoUsuario),\n/* harmony export */   atualizarQuantidadeCarrinho: () => (/* binding */ atualizarQuantidadeCarrinho),\n/* harmony export */   atualizarStatusPedido: () => (/* binding */ atualizarStatusPedido),\n/* harmony export */   criarPedido: () => (/* binding */ criarPedido),\n/* harmony export */   criarPedidoNovo: () => (/* binding */ criarPedidoNovo),\n/* harmony export */   getAlturasByTamanhoId: () => (/* binding */ getAlturasByTamanhoId),\n/* harmony export */   getCalculos: () => (/* binding */ getCalculos),\n/* harmony export */   getCalculosUsuario: () => (/* binding */ getCalculosUsuario),\n/* harmony export */   getCarrinhoUsuario: () => (/* binding */ getCarrinhoUsuario),\n/* harmony export */   getLargurasByAlturaId: () => (/* binding */ getLargurasByAlturaId),\n/* harmony export */   getPacoteByLarguraId: () => (/* binding */ getPacoteByLarguraId),\n/* harmony export */   getPacoteByProdutoNome: () => (/* binding */ getPacoteByProdutoNome),\n/* harmony export */   getPacoteValido: () => (/* binding */ getPacoteValido),\n/* harmony export */   getPedidos: () => (/* binding */ getPedidos),\n/* harmony export */   getPedidosCliente: () => (/* binding */ getPedidosCliente),\n/* harmony export */   getProduto: () => (/* binding */ getProduto),\n/* harmony export */   getProdutos: () => (/* binding */ getProdutos),\n/* harmony export */   getRevendedoresComProduto: () => (/* binding */ getRevendedoresComProduto),\n/* harmony export */   getRevendedoresParaProdutos: () => (/* binding */ getRevendedoresParaProdutos),\n/* harmony export */   getTamanhos: () => (/* binding */ getTamanhos),\n/* harmony export */   getUserInfo: () => (/* binding */ getUserInfo),\n/* harmony export */   getUsuarioIdRevendedor: () => (/* binding */ getUsuarioIdRevendedor),\n/* harmony export */   limparCarrinhoUsuario: () => (/* binding */ limparCarrinhoUsuario),\n/* harmony export */   registrarMudancaStatus: () => (/* binding */ registrarMudancaStatus),\n/* harmony export */   removerItemCarrinho: () => (/* binding */ removerItemCarrinho),\n/* harmony export */   salvarCalculo: () => (/* binding */ salvarCalculo),\n/* harmony export */   salvarCalculoUsuario: () => (/* binding */ salvarCalculoUsuario)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n// Funções para produtos\nasync function getProdutos() {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"produtos\").select(\"*\").order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n}\nasync function getProduto(id) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"produtos\").select(\"*\").eq(\"id\", id).single();\n    return {\n        data,\n        error\n    };\n}\n// Funções para cálculos\nasync function salvarCalculo(tamanhoRoda, altura, largura, resultado, cor) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"calculos\").insert([\n        {\n            tamanho_roda: tamanhoRoda,\n            altura: altura,\n            largura: largura,\n            resultado: resultado,\n            cor: cor\n        }\n    ]).select();\n    return {\n        data,\n        error\n    };\n}\n// Nova função para salvar cálculos do usuário com limite de 10\nasync function salvarCalculoUsuario(userId, tamanho, altura, largura, pacote) {\n    try {\n        // 1. Verificar quantos cálculos o usuário já tem\n        const { data: calculos, error: contarError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"calculo_usuarios\").select(\"id, created_at\").eq(\"userid\", userId).order(\"created_at\", {\n            ascending: true\n        });\n        if (contarError) {\n            console.error(\"Erro ao contar cálculos do usuário:\", contarError);\n            return {\n                data: null,\n                error: contarError\n            };\n        }\n        // 2. Se já tiver 10 ou mais, excluir o mais antigo\n        if (calculos && calculos.length >= 10) {\n            const calculoMaisAntigo = calculos[0];\n            const { error: deleteError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"calculo_usuarios\").delete().eq(\"id\", calculoMaisAntigo.id);\n            if (deleteError) {\n                console.error(\"Erro ao excluir cálculo mais antigo:\", deleteError);\n                return {\n                    data: null,\n                    error: deleteError\n                };\n            }\n        }\n        // 3. Inserir o novo cálculo\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"calculo_usuarios\").insert([\n            {\n                userid: userId,\n                tamanho: tamanho,\n                altura: altura,\n                largura: largura,\n                pacote: pacote,\n                created_at: new Date()\n            }\n        ]).select();\n        if (error) {\n            console.error(\"Erro ao salvar cálculo do usuário:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao salvar cálculo do usuário:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// Função para obter os cálculos do usuário\nasync function getCalculosUsuario(userId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"calculo_usuarios\").select(\"*\").eq(\"userid\", userId).order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n}\nasync function getCalculos(userId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"calculos\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n}\n// Funções para pedidos\nasync function criarPedido(userId, items, total) {\n    let tipoEntrega = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"retirada\", metodoPagamento = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"cartao\", dadosAdicionais = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n    try {\n        // Criar o pedido\n        const { data: pedido, error: pedidoError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedidos\").insert([\n            {\n                user_id: userId,\n                total: total,\n                tipo_entrega: tipoEntrega,\n                pagamento_tipo: metodoPagamento,\n                status: \"pendente\",\n                dados_adicionais: dadosAdicionais\n            }\n        ]).select().single();\n        if (pedidoError) throw pedidoError;\n        // Inserir os itens do pedido\n        const itens = items.map((item)=>({\n                pedido_id: pedido.id,\n                produto_nome: item.nome,\n                quantidade: item.quantidade,\n                preco_unitario: item.preco,\n                revendedor_id: item.revendedor_id\n            }));\n        const { error: itensError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"itens_pedido\").insert(itens);\n        if (itensError) throw itensError;\n        return {\n            data: pedido,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao criar pedido:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// Remover as funções getClienteByUsuarioId e garantirCliente que estavam criando uma tabela clientes desnecessária\n// Função para buscar pacote baseado no nome do produto\nasync function getPacoteByProdutoNome(produtoNome) {\n    try {\n        // Mapear nomes de produtos para pacotes\n        // Você pode ajustar essa lógica conforme sua regra de negócio\n        const mapeamentoProdutos = {\n            \"Microesferas Azul\": 1,\n            \"Microesferas Vermelha\": 2,\n            \"Microesferas Verde\": 3,\n            \"Microesferas Amarela\": 4,\n            \"Microesferas Preta\": 5,\n            \"Microesferas Branca\": 6\n        };\n        // Se existe um mapeamento direto, usar ele\n        if (mapeamentoProdutos[produtoNome]) {\n            return {\n                data: mapeamentoProdutos[produtoNome],\n                error: null\n            };\n        }\n        // Caso contrário, tentar buscar por nome similar\n        const { data: pacotes, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pacotes\").select(\"id, nome, cor\").ilike(\"nome\", \"%\".concat(produtoNome, \"%\")).limit(1);\n        if (error) {\n            console.error(\"Erro ao buscar pacote por nome:\", error);\n            return {\n                data: 1,\n                error: null\n            } // Fallback para ID 1\n            ;\n        }\n        if (pacotes && pacotes.length > 0) {\n            return {\n                data: pacotes[0].id,\n                error: null\n            };\n        }\n        // Se não encontrou nada, tentar buscar por cor\n        const cores = [\n            \"azul\",\n            \"vermelha\",\n            \"verde\",\n            \"amarela\",\n            \"preta\",\n            \"branca\"\n        ];\n        for (const cor of cores){\n            if (produtoNome.toLowerCase().includes(cor)) {\n                const { data: pacotePorCor, error: errorCor } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pacotes\").select(\"id\").ilike(\"cor\", \"%\".concat(cor, \"%\")).limit(1);\n                if (!errorCor && pacotePorCor && pacotePorCor.length > 0) {\n                    return {\n                        data: pacotePorCor[0].id,\n                        error: null\n                    };\n                }\n            }\n        }\n        // Fallback final\n        return {\n            data: 1,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao buscar pacote:\", error);\n        return {\n            data: 1,\n            error: null\n        };\n    }\n}\n// Função para buscar um pacote válido (por enquanto retorna o primeiro disponível)\nasync function getPacoteValido() {\n    try {\n        const { data: pacotes, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pacotes\").select(\"id\").limit(1);\n        if (error) {\n            console.error(\"Erro ao buscar pacote:\", error);\n            return 1 // Fallback para ID 1\n            ;\n        }\n        return pacotes && pacotes.length > 0 ? pacotes[0].id : 1;\n    } catch (error) {\n        console.error(\"Erro ao buscar pacote:\", error);\n        return 1 // Fallback para ID 1\n        ;\n    }\n}\n// Função para registrar mudança de status no histórico\nasync function registrarMudancaStatus(pedidoId, statusAnterior, statusNovo, observacao, updatedBy) {\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedido_historico_status\").insert([\n            {\n                pedido_id: pedidoId,\n                status_anterior: statusAnterior,\n                status_novo: statusNovo,\n                observacao: observacao,\n                updated_by: updatedBy\n            }\n        ]).select();\n        if (error) {\n            console.error(\"Erro ao registrar mudança de status:\", error);\n        }\n        return {\n            data,\n            error\n        };\n    } catch (error) {\n        console.error(\"Erro ao registrar mudança de status:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// Substituir a função criarPedidoNovo por esta versão corrigida:\nasync function criarPedidoNovo(userId, revendedorId, items, valorTotal, frete, tipoEntrega, metodoPagamento) {\n    try {\n        console.log(\"Iniciando criação do pedido para usuário:\", userId);\n        // Converter userId para número\n        const clienteId = Number.parseInt(userId);\n        // Buscar o usuario_id do revendedor baseado no revendedor_id\n        const { data: revendedorUsuarioId, error: revendedorError } = await getUsuarioIdRevendedor(revendedorId);\n        if (revendedorError || !revendedorUsuarioId) {\n            throw new Error(\"Erro ao buscar revendedor: \" + ((revendedorError === null || revendedorError === void 0 ? void 0 : revendedorError.message) || \"Revendedor não encontrado\"));\n        }\n        console.log(\"Cliente ID:\", clienteId);\n        console.log(\"Revendedor ID:\", revendedorId);\n        console.log(\"Revendedor Usuario ID:\", revendedorUsuarioId);\n        // Gerar número do pedido único\n        const numeroPedido = \"PED-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 4).toUpperCase());\n        // Definir status inicial baseado no tipo de entrega\n        const statusInicial = tipoEntrega === \"retirada\" ? \"aguardando_preparacao\" : \"aguardando_aceite\";\n        // Criar o pedido usando o schema correto\n        const { data: pedido, error: pedidoError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedidos\").insert([\n            {\n                cliente_id: clienteId,\n                revendedor_id: revendedorUsuarioId,\n                numero: numeroPedido,\n                frete: frete,\n                valor_total: valorTotal,\n                pagamento_tipo: metodoPagamento,\n                tipo_entrega: tipoEntrega,\n                status: \"pago\",\n                status_detalhado: statusInicial,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }\n        ]).select().single();\n        if (pedidoError) {\n            console.error(\"Erro ao criar pedido:\", pedidoError);\n            throw pedidoError;\n        }\n        console.log(\"Pedido criado com sucesso:\", pedido);\n        // Registrar o status inicial no histórico\n        await registrarMudancaStatus(pedido.id, null, statusInicial, \"Pedido criado\", null);\n        // Preparar itens para inserção com pacote_id correto para cada item\n        const itensParaInserir = await Promise.all(items.map(async (item, index)=>{\n            // Buscar o pacote_id correto baseado no nome do produto\n            const { data: pacoteId } = await getPacoteByProdutoNome(item.nome);\n            const itemParaInserir = {\n                pedido_id: pedido.id,\n                pacote_id: pacoteId,\n                qtd: Number(item.quantidade) || 0,\n                valor_unitario: Number(item.preco) || 0\n            };\n            console.log(\"Item \".concat(index + 1, \" preparado:\"), itemParaInserir);\n            console.log(\"Produto: \".concat(item.nome, \" -> Pacote ID: \").concat(pacoteId));\n            return itemParaInserir;\n        }));\n        console.log(\"Todos os itens preparados:\", itensParaInserir);\n        // Inserir os itens do pedido\n        const { data: itensInseridos, error: itensError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedido_itens\").insert(itensParaInserir).select();\n        if (itensError) {\n            console.error(\"Erro detalhado ao inserir itens do pedido:\", itensError);\n            console.error(\"Dados que tentamos inserir:\", itensParaInserir);\n            throw itensError;\n        }\n        console.log(\"Itens inseridos com sucesso:\", itensInseridos);\n        return {\n            data: pedido,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao criar pedido:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// Função para atualizar status do pedido\nasync function atualizarStatusPedido(pedidoId, novoStatus, dataEstimada, observacoes, updatedBy) {\n    try {\n        // Primeiro, buscar o status atual\n        const { data: pedidoAtual, error: errorBusca } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedidos\").select(\"status_detalhado\").eq(\"id\", pedidoId).single();\n        if (errorBusca) {\n            throw errorBusca;\n        }\n        // Preparar dados para atualização\n        const dadosAtualizacao = {\n            status_detalhado: novoStatus,\n            updated_at: new Date().toISOString()\n        };\n        if (dataEstimada) {\n            dadosAtualizacao.data_estimada_entrega = dataEstimada;\n        }\n        if (observacoes) {\n            dadosAtualizacao.observacoes_revendedor = observacoes;\n        }\n        // Se o status for \"entregue\" ou \"retirado\", definir data real\n        if (novoStatus === \"entregue\" || novoStatus === \"retirado\") {\n            dadosAtualizacao.data_entrega_real = new Date().toISOString();\n        }\n        // Atualizar o pedido\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedidos\").update(dadosAtualizacao).eq(\"id\", pedidoId).select();\n        if (error) {\n            throw error;\n        }\n        // Registrar mudança no histórico\n        await registrarMudancaStatus(pedidoId, pedidoAtual.status_detalhado, novoStatus, observacoes, updatedBy);\n        return {\n            data,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao atualizar status do pedido:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\nasync function getPedidos(userId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedidos\").select(\"\\n      *,\\n      itens_pedido:itens_pedido(\\n        *,\\n        produto:produtos(*)\\n      )\\n    \").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n}\n// Substituir a função getPedidosCliente por esta versão corrigida:\nasync function getPedidosCliente(userId) {\n    try {\n        console.log(\"Buscando pedidos para usuário:\", userId);\n        // Converter userId para número\n        const clienteId = Number.parseInt(userId);\n        // Buscar pedidos usando o cliente_id diretamente\n        const { data: pedidos, error: pedidosError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pedidos\").select(\"\\n        *,\\n        pedido_itens:pedido_itens(\\n          id,\\n          pedido_id,\\n          pacote_id,\\n          qtd,\\n          valor_unitario,\\n          pacotes:pacotes(id, nome, cor, imagem)\\n        )\\n      \").eq(\"cliente_id\", clienteId) // Corrigido: cliente_id em vez de client_id\n        .order(\"created_at\", {\n            ascending: false\n        });\n        console.log(\"Pedidos encontrados:\", (pedidos === null || pedidos === void 0 ? void 0 : pedidos.length) || 0);\n        if (pedidosError) {\n            console.error(\"Erro ao buscar pedidos:\", pedidosError);\n            throw pedidosError;\n        }\n        return {\n            data: pedidos || [],\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao buscar pedidos do cliente:\", error);\n        return {\n            data: [],\n            error\n        };\n    }\n}\n// Função para buscar tamanhos de rodas disponíveis\nasync function getTamanhos() {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"tamanhos\").select(\"id, nome\").order(\"nome\", {\n        ascending: true\n    });\n    return {\n        data,\n        error\n    };\n}\n// Função para buscar alturas disponíveis com base no tamanho da roda\nasync function getAlturasByTamanhoId(tamanhoId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"alturas\").select(\"id, valor\").eq(\"tamanho_id\", tamanhoId).order(\"valor\", {\n        ascending: true\n    });\n    // Remover duplicatas baseado no valor\n    if (data && data.length > 0) {\n        const uniqueAlturas = data.reduce((acc, current)=>{\n            const exists = acc.find((item)=>item.valor === current.valor);\n            if (!exists) {\n                acc.push(current);\n            }\n            return acc;\n        }, []);\n        return {\n            data: uniqueAlturas,\n            error\n        };\n    }\n    return {\n        data,\n        error\n    };\n}\n// Função para buscar larguras based on altura_id\nasync function getLargurasByAlturaId(alturaId) {\n    console.log(\"🔍 Buscando larguras para alturaId:\", alturaId);\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"larguras\").select(\"id, valor\").eq(\"altura_id\", alturaId).order(\"valor\", {\n        ascending: true\n    });\n    // Remover duplicatas baseado no valor\n    if (data && data.length > 0) {\n        const uniqueLarguras = data.reduce((acc, current)=>{\n            const exists = acc.find((item)=>item.valor === current.valor);\n            if (!exists) {\n                acc.push(current);\n            }\n            return acc;\n        }, []);\n        console.log(\"📏 Larguras únicas encontradas:\", {\n            data: uniqueLarguras,\n            error\n        });\n        return {\n            data: uniqueLarguras,\n            error\n        };\n    }\n    console.log(\"📏 Larguras encontradas:\", {\n        data,\n        error\n    });\n    return {\n        data,\n        error\n    };\n}\n// Função para buscar package details by largura_id\nasync function getPacoteByLarguraId(larguraId) {\n    try {\n        console.log(\"🔍 Buscando pacote para larguraId:\", larguraId);\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"pacotes\").select(\"*\").eq(\"largura_id\", larguraId).single();\n        console.log(\"📦 Resultado da busca:\", {\n            data,\n            error\n        });\n        if (error) {\n            console.error(\"❌ Erro ao buscar pacote por largura_id:\", error);\n            // Fallback: retornar um pacote padrão\n            return {\n                data: {\n                    id: 1,\n                    nome: \"LTP60\",\n                    cor: \"#4A4953\"\n                },\n                error: null\n            };\n        }\n        if (!data) {\n            console.log(\"Nenhum pacote encontrado para largura_id:\", larguraId);\n            // Fallback: retornar um pacote padrão\n            return {\n                data: {\n                    id: 1,\n                    nome: \"LTP60\",\n                    cor: \"#4A4953\"\n                },\n                error: null\n            };\n        }\n        // Ajustar dados se nome estiver null\n        const pacoteAjustado = {\n            id: data.id,\n            nome: data.nome || data.descricao || \"LTP60\",\n            cor: data.cor || \"#949698\" // Cor padrão baseada nos dados existentes\n        };\n        return {\n            data: pacoteAjustado,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao buscar pacote:\", error);\n        // Fallback: retornar um pacote padrão\n        return {\n            data: {\n                id: 1,\n                nome: \"LTP60\",\n                cor: \"#4A4953\"\n            },\n            error: null\n        };\n    }\n}\n// ==================== FUNÇÕES DO CARRINHO ====================\n// Buscar carrinho do usuário\nasync function getCarrinhoUsuario(userId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").select(\"*\").eq(\"user_id\", userId).order(\"created_at\", {\n        ascending: false\n    });\n    return {\n        data,\n        error\n    };\n}\n// Adicionar item ao carrinho\nasync function adicionarItemCarrinho(userId, produtoNome) {\n    let quantidade = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5, imagem = arguments.length > 3 ? arguments[3] : void 0;\n    // Ensure quantity is a multiple of 5 and at least 5\n    const adjustedQuantity = Math.max(Math.round(quantidade / 5) * 5, 5);\n    // Verificar se o item já existe no carrinho\n    const { data: itemExistente, error: errorBusca } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").select(\"*\").eq(\"user_id\", userId).eq(\"produto_nome\", produtoNome).single();\n    if (errorBusca && errorBusca.code !== \"PGRST116\") {\n        // PGRST116 = No rows found (esperado se item não existe)\n        return {\n            data: null,\n            error: errorBusca\n        };\n    }\n    if (itemExistente) {\n        // Item já existe, adicionar 5 unidades\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").update({\n            quantidade: itemExistente.quantidade + 5,\n            updated_at: new Date().toISOString()\n        }).eq(\"id\", itemExistente.id).select();\n        return {\n            data,\n            error\n        };\n    } else {\n        // Item não existe, criar novo com quantidade ajustada\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").insert([\n            {\n                user_id: userId,\n                produto_nome: produtoNome,\n                quantidade: adjustedQuantity,\n                imagem: imagem\n            }\n        ]).select();\n        return {\n            data,\n            error\n        };\n    }\n}\n// Atualizar quantidade de item no carrinho\nasync function atualizarQuantidadeCarrinho(userId, produtoNome, quantidade) {\n    // Ensure quantity is a multiple of 5 and at least 5\n    const adjustedQuantity = Math.max(Math.round(quantidade / 5) * 5, 5);\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").update({\n        quantidade: adjustedQuantity,\n        updated_at: new Date().toISOString()\n    }).eq(\"user_id\", userId).eq(\"produto_nome\", produtoNome).select();\n    return {\n        data,\n        error\n    };\n}\n// Remover item do carrinho\nasync function removerItemCarrinho(userId, produtoNome) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").delete().eq(\"user_id\", userId).eq(\"produto_nome\", produtoNome);\n    return {\n        data,\n        error\n    };\n}\n// Limpar carrinho do usuário\nasync function limparCarrinhoUsuario(userId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").delete().eq(\"user_id\", userId);\n    return {\n        data,\n        error\n    };\n}\n// Atualizar carrinho completo do usuário\nasync function atualizarCarrinhoUsuario(userId, items) {\n    try {\n        // Primeiro, limpar o carrinho atual\n        await limparCarrinhoUsuario(userId);\n        // Se não há itens, apenas retornar sucesso\n        if (!items || items.length === 0) {\n            return {\n                data: null,\n                error: null\n            };\n        }\n        // Inserir todos os novos itens\n        const itensParaInserir = items.map((item)=>({\n                user_id: userId,\n                produto_nome: item.nome,\n                quantidade: item.quantidade,\n                imagem: item.imagem,\n                created_at: new Date().toISOString()\n            }));\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"carrinho_usuarios\").insert(itensParaInserir).select();\n        return {\n            data,\n            error\n        };\n    } catch (error) {\n        console.error(\"Erro ao atualizar carrinho:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n// ==================== FUNÇÕES DE REVENDEDORES E ESTOQUE ====================\n// Buscar revendedores que possuem um produto específico em estoque\nasync function getRevendedoresComProduto(produtoNome) {\n    // Usando JOIN manual em vez de relacionamento\n    const { data: estoque, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"revendedor_estoque\").select(\"\\n      id,\\n      revendedor_id,\\n      produto,\\n      quantidade,\\n      preco,\\n      status\\n    \").eq(\"produto\", produtoNome).gt(\"quantidade\", 0) // Apenas com estoque disponível\n    ;\n    if (error) {\n        return {\n            data: null,\n            error\n        };\n    }\n    // Buscar informações dos revendedores\n    const revendedorIds = (estoque === null || estoque === void 0 ? void 0 : estoque.map((item)=>item.revendedor_id)) || [];\n    if (revendedorIds.length === 0) {\n        return {\n            data: [],\n            error: null\n        };\n    }\n    const { data: revendedores, error: revendedoresError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"revendedores\").select(\"\\n      id,\\n      usuario_id,\\n      loja,\\n      cidade,\\n      uf,\\n      frete,\\n      vendas,\\n      status\\n    \").in(\"id\", revendedorIds);\n    if (revendedoresError) {\n        return {\n            data: null,\n            error: revendedoresError\n        };\n    }\n    // Combinar os dados\n    const resultado = (estoque === null || estoque === void 0 ? void 0 : estoque.map((item)=>{\n        const revendedor = revendedores === null || revendedores === void 0 ? void 0 : revendedores.find((r)=>r.id === item.revendedor_id);\n        return {\n            ...item,\n            revendedor: revendedor || null\n        };\n    }).filter((item)=>item.revendedor !== null)) || [];\n    // Ordenar por preço\n    resultado.sort((a, b)=>a.preco - b.preco);\n    return {\n        data: resultado,\n        error: null\n    };\n}\n// Buscar revendedores para múltiplos produtos\nasync function getRevendedoresParaProdutos(produtoNomes) {\n    if (!produtoNomes.length) return {\n        data: {},\n        error: null\n    };\n    // Buscar todos os produtos de uma vez\n    const { data: estoque, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"revendedor_estoque\").select(\"\\n      id,\\n      revendedor_id,\\n      produto,\\n      quantidade,\\n      preco,\\n      status\\n    \").in(\"produto\", produtoNomes).gt(\"quantidade\", 0) // Apenas com estoque disponível\n    ;\n    if (error) {\n        return {\n            data: {},\n            error\n        };\n    }\n    if (!estoque || estoque.length === 0) {\n        return {\n            data: {},\n            error: null\n        };\n    }\n    // Buscar informações dos revendedores\n    const revendedorIds = [\n        ...new Set(estoque.map((item)=>item.revendedor_id))\n    ];\n    const { data: revendedores, error: revendedoresError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"revendedores\").select(\"\\n      id,\\n      usuario_id,\\n      loja,\\n      cidade,\\n      uf,\\n      frete,\\n      vendas,\\n      status\\n    \").in(\"id\", revendedorIds);\n    if (revendedoresError) {\n        return {\n            data: {},\n            error: revendedoresError\n        };\n    }\n    // Combinar os dados e agrupar por produto\n    const produtosAgrupados = {};\n    produtoNomes.forEach((produtoNome)=>{\n        const produtoEstoque = estoque.filter((item)=>item.produto === produtoNome).map((item)=>{\n            const revendedor = revendedores === null || revendedores === void 0 ? void 0 : revendedores.find((r)=>r.id === item.revendedor_id);\n            return revendedor ? {\n                ...item,\n                revendedor\n            } : null;\n        }).filter((item)=>item !== null);\n        // Ordenar por preço\n        produtoEstoque.sort((a, b)=>a.preco - b.preco);\n        produtosAgrupados[produtoNome] = produtoEstoque;\n    });\n    return {\n        data: produtosAgrupados,\n        error: null\n    };\n}\n// Buscar informações do usuário\nasync function getUserInfo(userId) {\n    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"usuarios\").select(\"id, nome, email, cidade, uf, cep, rua, bairro, complemento, numero\").eq(\"id\", userId).single();\n    return {\n        data,\n        error\n    };\n}\n// Função para buscar usuario_id do revendedor baseado no revendedor_id\nasync function getUsuarioIdRevendedor(revendedorId) {\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"revendedores\").select(\"usuario_id\").eq(\"id\", revendedorId).single();\n        if (error) {\n            console.error(\"Erro ao buscar usuario_id do revendedor:\", error);\n            return {\n                data: null,\n                error\n            };\n        }\n        return {\n            data: data.usuario_id,\n            error: null\n        };\n    } catch (error) {\n        console.error(\"Erro ao buscar usuario_id do revendedor:\", error);\n        return {\n            data: null,\n            error\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWJhc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tIFwiLi9zdXBhYmFzZVwiXG5cbi8vIEZ1bsOnw7VlcyBwYXJhIHByb2R1dG9zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZHV0b3MoKSB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJwcm9kdXRvc1wiKS5zZWxlY3QoXCIqXCIpLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9kdXRvKGlkOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInByb2R1dG9zXCIpLnNlbGVjdChcIipcIikuZXEoXCJpZFwiLCBpZCkuc2luZ2xlKClcblxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG59XG5cbi8vIEZ1bsOnw7VlcyBwYXJhIGPDoWxjdWxvc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhbHZhckNhbGN1bG8oXG4gIHRhbWFuaG9Sb2RhOiBzdHJpbmcsXG4gIGFsdHVyYTogc3RyaW5nLFxuICBsYXJndXJhOiBzdHJpbmcsXG4gIHJlc3VsdGFkbzogc3RyaW5nLFxuICBjb3I6IHN0cmluZyxcbikge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiY2FsY3Vsb3NcIilcbiAgICAuaW5zZXJ0KFtcbiAgICAgIHtcbiAgICAgICAgdGFtYW5ob19yb2RhOiB0YW1hbmhvUm9kYSxcbiAgICAgICAgYWx0dXJhOiBhbHR1cmEsXG4gICAgICAgIGxhcmd1cmE6IGxhcmd1cmEsXG4gICAgICAgIHJlc3VsdGFkbzogcmVzdWx0YWRvLFxuICAgICAgICBjb3I6IGNvcixcbiAgICAgIH0sXG4gICAgXSlcbiAgICAuc2VsZWN0KClcblxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG59XG5cbi8vIE5vdmEgZnVuw6fDo28gcGFyYSBzYWx2YXIgY8OhbGN1bG9zIGRvIHVzdcOhcmlvIGNvbSBsaW1pdGUgZGUgMTBcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYWx2YXJDYWxjdWxvVXN1YXJpbyhcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHRhbWFuaG86IHN0cmluZyxcbiAgYWx0dXJhOiBzdHJpbmcsXG4gIGxhcmd1cmE6IHN0cmluZyxcbiAgcGFjb3RlOiBzdHJpbmcsXG4pIHtcbiAgdHJ5IHtcbiAgICAvLyAxLiBWZXJpZmljYXIgcXVhbnRvcyBjw6FsY3Vsb3MgbyB1c3XDoXJpbyBqw6EgdGVtXG4gICAgY29uc3QgeyBkYXRhOiBjYWxjdWxvcywgZXJyb3I6IGNvbnRhckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJjYWxjdWxvX3VzdWFyaW9zXCIpXG4gICAgICAuc2VsZWN0KFwiaWQsIGNyZWF0ZWRfYXRcIilcbiAgICAgIC5lcShcInVzZXJpZFwiLCB1c2VySWQpXG4gICAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICBpZiAoY29udGFyRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGNvbnRhciBjw6FsY3Vsb3MgZG8gdXN1w6FyaW86XCIsIGNvbnRhckVycm9yKVxuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNvbnRhckVycm9yIH1cbiAgICB9XG5cbiAgICAvLyAyLiBTZSBqw6EgdGl2ZXIgMTAgb3UgbWFpcywgZXhjbHVpciBvIG1haXMgYW50aWdvXG4gICAgaWYgKGNhbGN1bG9zICYmIGNhbGN1bG9zLmxlbmd0aCA+PSAxMCkge1xuICAgICAgY29uc3QgY2FsY3Vsb01haXNBbnRpZ28gPSBjYWxjdWxvc1swXVxuICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJjYWxjdWxvX3VzdWFyaW9zXCIpLmRlbGV0ZSgpLmVxKFwiaWRcIiwgY2FsY3Vsb01haXNBbnRpZ28uaWQpXG5cbiAgICAgIGlmIChkZWxldGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBleGNsdWlyIGPDoWxjdWxvIG1haXMgYW50aWdvOlwiLCBkZWxldGVFcnJvcilcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGRlbGV0ZUVycm9yIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBJbnNlcmlyIG8gbm92byBjw6FsY3Vsb1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImNhbGN1bG9fdXN1YXJpb3NcIilcbiAgICAgIC5pbnNlcnQoW1xuICAgICAgICB7XG4gICAgICAgICAgdXNlcmlkOiB1c2VySWQsXG4gICAgICAgICAgdGFtYW5obzogdGFtYW5obyxcbiAgICAgICAgICBhbHR1cmE6IGFsdHVyYSxcbiAgICAgICAgICBsYXJndXJhOiBsYXJndXJhLFxuICAgICAgICAgIHBhY290ZTogcGFjb3RlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICAgLnNlbGVjdCgpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIHNhbHZhciBjw6FsY3VsbyBkbyB1c3XDoXJpbzpcIiwgZXJyb3IpXG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIHNhbHZhciBjw6FsY3VsbyBkbyB1c3XDoXJpbzpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICB9XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgb2J0ZXIgb3MgY8OhbGN1bG9zIGRvIHVzdcOhcmlvXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsY3Vsb3NVc3VhcmlvKHVzZXJJZDogc3RyaW5nKSB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJjYWxjdWxvX3VzdWFyaW9zXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJ1c2VyaWRcIiwgdXNlcklkKVxuICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsY3Vsb3ModXNlcklkOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImNhbGN1bG9zXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJ1c2VyX2lkXCIsIHVzZXJJZClcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbn1cblxuLy8gRnVuw6fDtWVzIHBhcmEgcGVkaWRvc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyaWFyUGVkaWRvKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgaXRlbXM6IGFueVtdLFxuICB0b3RhbDogbnVtYmVyLFxuICB0aXBvRW50cmVnYSA9IFwicmV0aXJhZGFcIixcbiAgbWV0b2RvUGFnYW1lbnRvID0gXCJjYXJ0YW9cIixcbiAgZGFkb3NBZGljaW9uYWlzOiBhbnkgPSB7fSxcbikge1xuICB0cnkge1xuICAgIC8vIENyaWFyIG8gcGVkaWRvXG4gICAgY29uc3QgeyBkYXRhOiBwZWRpZG8sIGVycm9yOiBwZWRpZG9FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwicGVkaWRvc1wiKVxuICAgICAgLmluc2VydChbXG4gICAgICAgIHtcbiAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgdG90YWw6IHRvdGFsLFxuICAgICAgICAgIHRpcG9fZW50cmVnYTogdGlwb0VudHJlZ2EsXG4gICAgICAgICAgcGFnYW1lbnRvX3RpcG86IG1ldG9kb1BhZ2FtZW50byxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGVudGVcIixcbiAgICAgICAgICBkYWRvc19hZGljaW9uYWlzOiBkYWRvc0FkaWNpb25haXMsIC8vIEFybWF6ZW5hIG8gZW5kZXJlw6dvIGFsdGVybmF0aXZvIHNlIGV4aXN0aXJcbiAgICAgICAgfSxcbiAgICAgIF0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKHBlZGlkb0Vycm9yKSB0aHJvdyBwZWRpZG9FcnJvclxuXG4gICAgLy8gSW5zZXJpciBvcyBpdGVucyBkbyBwZWRpZG9cbiAgICBjb25zdCBpdGVucyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gKHtcbiAgICAgIHBlZGlkb19pZDogcGVkaWRvLmlkLFxuICAgICAgcHJvZHV0b19ub21lOiBpdGVtLm5vbWUsXG4gICAgICBxdWFudGlkYWRlOiBpdGVtLnF1YW50aWRhZGUsXG4gICAgICBwcmVjb191bml0YXJpbzogaXRlbS5wcmVjbyxcbiAgICAgIHJldmVuZGVkb3JfaWQ6IGl0ZW0ucmV2ZW5kZWRvcl9pZCxcbiAgICB9KSlcblxuICAgIGNvbnN0IHsgZXJyb3I6IGl0ZW5zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJpdGVuc19wZWRpZG9cIikuaW5zZXJ0KGl0ZW5zKVxuXG4gICAgaWYgKGl0ZW5zRXJyb3IpIHRocm93IGl0ZW5zRXJyb3JcblxuICAgIHJldHVybiB7IGRhdGE6IHBlZGlkbywgZXJyb3I6IG51bGwgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGNyaWFyIHBlZGlkbzpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICB9XG59XG5cbi8vIFJlbW92ZXIgYXMgZnVuw6fDtWVzIGdldENsaWVudGVCeVVzdWFyaW9JZCBlIGdhcmFudGlyQ2xpZW50ZSBxdWUgZXN0YXZhbSBjcmlhbmRvIHVtYSB0YWJlbGEgY2xpZW50ZXMgZGVzbmVjZXNzw6FyaWFcblxuLy8gRnVuw6fDo28gcGFyYSBidXNjYXIgcGFjb3RlIGJhc2VhZG8gbm8gbm9tZSBkbyBwcm9kdXRvXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFjb3RlQnlQcm9kdXRvTm9tZShwcm9kdXRvTm9tZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgLy8gTWFwZWFyIG5vbWVzIGRlIHByb2R1dG9zIHBhcmEgcGFjb3Rlc1xuICAgIC8vIFZvY8OqIHBvZGUgYWp1c3RhciBlc3NhIGzDs2dpY2EgY29uZm9ybWUgc3VhIHJlZ3JhIGRlIG5lZ8OzY2lvXG4gICAgY29uc3QgbWFwZWFtZW50b1Byb2R1dG9zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICAgXCJNaWNyb2VzZmVyYXMgQXp1bFwiOiAxLFxuICAgICAgXCJNaWNyb2VzZmVyYXMgVmVybWVsaGFcIjogMixcbiAgICAgIFwiTWljcm9lc2ZlcmFzIFZlcmRlXCI6IDMsXG4gICAgICBcIk1pY3JvZXNmZXJhcyBBbWFyZWxhXCI6IDQsXG4gICAgICBcIk1pY3JvZXNmZXJhcyBQcmV0YVwiOiA1LFxuICAgICAgXCJNaWNyb2VzZmVyYXMgQnJhbmNhXCI6IDYsXG4gICAgfVxuXG4gICAgLy8gU2UgZXhpc3RlIHVtIG1hcGVhbWVudG8gZGlyZXRvLCB1c2FyIGVsZVxuICAgIGlmIChtYXBlYW1lbnRvUHJvZHV0b3NbcHJvZHV0b05vbWVdKSB7XG4gICAgICByZXR1cm4geyBkYXRhOiBtYXBlYW1lbnRvUHJvZHV0b3NbcHJvZHV0b05vbWVdLCBlcnJvcjogbnVsbCB9XG4gICAgfVxuXG4gICAgLy8gQ2FzbyBjb250csOhcmlvLCB0ZW50YXIgYnVzY2FyIHBvciBub21lIHNpbWlsYXJcbiAgICBjb25zdCB7IGRhdGE6IHBhY290ZXMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJwYWNvdGVzXCIpXG4gICAgICAuc2VsZWN0KFwiaWQsIG5vbWUsIGNvclwiKVxuICAgICAgLmlsaWtlKFwibm9tZVwiLCBgJSR7cHJvZHV0b05vbWV9JWApXG4gICAgICAubGltaXQoMSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gYnVzY2FyIHBhY290ZSBwb3Igbm9tZTpcIiwgZXJyb3IpXG4gICAgICByZXR1cm4geyBkYXRhOiAxLCBlcnJvcjogbnVsbCB9IC8vIEZhbGxiYWNrIHBhcmEgSUQgMVxuICAgIH1cblxuICAgIGlmIChwYWNvdGVzICYmIHBhY290ZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHsgZGF0YTogcGFjb3Rlc1swXS5pZCwgZXJyb3I6IG51bGwgfVxuICAgIH1cblxuICAgIC8vIFNlIG7Do28gZW5jb250cm91IG5hZGEsIHRlbnRhciBidXNjYXIgcG9yIGNvclxuICAgIGNvbnN0IGNvcmVzID0gW1wiYXp1bFwiLCBcInZlcm1lbGhhXCIsIFwidmVyZGVcIiwgXCJhbWFyZWxhXCIsIFwicHJldGFcIiwgXCJicmFuY2FcIl1cbiAgICBmb3IgKGNvbnN0IGNvciBvZiBjb3Jlcykge1xuICAgICAgaWYgKHByb2R1dG9Ob21lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoY29yKSkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHBhY290ZVBvckNvciwgZXJyb3I6IGVycm9yQ29yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKFwicGFjb3Rlc1wiKVxuICAgICAgICAgIC5zZWxlY3QoXCJpZFwiKVxuICAgICAgICAgIC5pbGlrZShcImNvclwiLCBgJSR7Y29yfSVgKVxuICAgICAgICAgIC5saW1pdCgxKVxuXG4gICAgICAgIGlmICghZXJyb3JDb3IgJiYgcGFjb3RlUG9yQ29yICYmIHBhY290ZVBvckNvci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YTogcGFjb3RlUG9yQ29yWzBdLmlkLCBlcnJvcjogbnVsbCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmaW5hbFxuICAgIHJldHVybiB7IGRhdGE6IDEsIGVycm9yOiBudWxsIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgcGFjb3RlOlwiLCBlcnJvcilcbiAgICByZXR1cm4geyBkYXRhOiAxLCBlcnJvcjogbnVsbCB9XG4gIH1cbn1cblxuLy8gRnVuw6fDo28gcGFyYSBidXNjYXIgdW0gcGFjb3RlIHbDoWxpZG8gKHBvciBlbnF1YW50byByZXRvcm5hIG8gcHJpbWVpcm8gZGlzcG9uw612ZWwpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFjb3RlVmFsaWRvKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YTogcGFjb3RlcywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oXCJwYWNvdGVzXCIpLnNlbGVjdChcImlkXCIpLmxpbWl0KDEpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGJ1c2NhciBwYWNvdGU6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIDEgLy8gRmFsbGJhY2sgcGFyYSBJRCAxXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhY290ZXMgJiYgcGFjb3Rlcy5sZW5ndGggPiAwID8gcGFjb3Rlc1swXS5pZCA6IDFcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgcGFjb3RlOlwiLCBlcnJvcilcbiAgICByZXR1cm4gMSAvLyBGYWxsYmFjayBwYXJhIElEIDFcbiAgfVxufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIHJlZ2lzdHJhciBtdWRhbsOnYSBkZSBzdGF0dXMgbm8gaGlzdMOzcmljb1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZ2lzdHJhck11ZGFuY2FTdGF0dXMoXG4gIHBlZGlkb0lkOiBudW1iZXIsXG4gIHN0YXR1c0FudGVyaW9yOiBzdHJpbmcgfCBudWxsLFxuICBzdGF0dXNOb3ZvOiBzdHJpbmcsXG4gIG9ic2VydmFjYW8/OiBzdHJpbmcsXG4gIHVwZGF0ZWRCeT86IG51bWJlcixcbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInBlZGlkb19oaXN0b3JpY29fc3RhdHVzXCIpXG4gICAgICAuaW5zZXJ0KFtcbiAgICAgICAge1xuICAgICAgICAgIHBlZGlkb19pZDogcGVkaWRvSWQsXG4gICAgICAgICAgc3RhdHVzX2FudGVyaW9yOiBzdGF0dXNBbnRlcmlvcixcbiAgICAgICAgICBzdGF0dXNfbm92bzogc3RhdHVzTm92byxcbiAgICAgICAgICBvYnNlcnZhY2FvOiBvYnNlcnZhY2FvLFxuICAgICAgICAgIHVwZGF0ZWRfYnk6IHVwZGF0ZWRCeSxcbiAgICAgICAgfSxcbiAgICAgIF0pXG4gICAgICAuc2VsZWN0KClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gcmVnaXN0cmFyIG11ZGFuw6dhIGRlIHN0YXR1czpcIiwgZXJyb3IpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIHJlZ2lzdHJhciBtdWRhbsOnYSBkZSBzdGF0dXM6XCIsIGVycm9yKVxuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgfVxufVxuXG4vLyBTdWJzdGl0dWlyIGEgZnVuw6fDo28gY3JpYXJQZWRpZG9Ob3ZvIHBvciBlc3RhIHZlcnPDo28gY29ycmlnaWRhOlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyaWFyUGVkaWRvTm92byhcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHJldmVuZGVkb3JJZDogbnVtYmVyLFxuICBpdGVtczogYW55W10sXG4gIHZhbG9yVG90YWw6IG51bWJlcixcbiAgZnJldGU6IG51bWJlcixcbiAgdGlwb0VudHJlZ2E6IHN0cmluZyxcbiAgbWV0b2RvUGFnYW1lbnRvOiBzdHJpbmcsXG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIkluaWNpYW5kbyBjcmlhw6fDo28gZG8gcGVkaWRvIHBhcmEgdXN1w6FyaW86XCIsIHVzZXJJZClcblxuICAgIC8vIENvbnZlcnRlciB1c2VySWQgcGFyYSBuw7ptZXJvXG4gICAgY29uc3QgY2xpZW50ZUlkID0gTnVtYmVyLnBhcnNlSW50KHVzZXJJZClcblxuICAgIC8vIEJ1c2NhciBvIHVzdWFyaW9faWQgZG8gcmV2ZW5kZWRvciBiYXNlYWRvIG5vIHJldmVuZGVkb3JfaWRcbiAgICBjb25zdCB7IGRhdGE6IHJldmVuZGVkb3JVc3VhcmlvSWQsIGVycm9yOiByZXZlbmRlZG9yRXJyb3IgfSA9IGF3YWl0IGdldFVzdWFyaW9JZFJldmVuZGVkb3IocmV2ZW5kZWRvcklkKVxuXG4gICAgaWYgKHJldmVuZGVkb3JFcnJvciB8fCAhcmV2ZW5kZWRvclVzdWFyaW9JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJybyBhbyBidXNjYXIgcmV2ZW5kZWRvcjogXCIgKyAocmV2ZW5kZWRvckVycm9yPy5tZXNzYWdlIHx8IFwiUmV2ZW5kZWRvciBuw6NvIGVuY29udHJhZG9cIikpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJDbGllbnRlIElEOlwiLCBjbGllbnRlSWQpXG4gICAgY29uc29sZS5sb2coXCJSZXZlbmRlZG9yIElEOlwiLCByZXZlbmRlZG9ySWQpXG4gICAgY29uc29sZS5sb2coXCJSZXZlbmRlZG9yIFVzdWFyaW8gSUQ6XCIsIHJldmVuZGVkb3JVc3VhcmlvSWQpXG5cbiAgICAvLyBHZXJhciBuw7ptZXJvIGRvIHBlZGlkbyDDum5pY29cbiAgICBjb25zdCBudW1lcm9QZWRpZG8gPSBgUEVELSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNCkudG9VcHBlckNhc2UoKX1gXG5cbiAgICAvLyBEZWZpbmlyIHN0YXR1cyBpbmljaWFsIGJhc2VhZG8gbm8gdGlwbyBkZSBlbnRyZWdhXG4gICAgY29uc3Qgc3RhdHVzSW5pY2lhbCA9IHRpcG9FbnRyZWdhID09PSBcInJldGlyYWRhXCIgPyBcImFndWFyZGFuZG9fcHJlcGFyYWNhb1wiIDogXCJhZ3VhcmRhbmRvX2FjZWl0ZVwiXG5cbiAgICAvLyBDcmlhciBvIHBlZGlkbyB1c2FuZG8gbyBzY2hlbWEgY29ycmV0b1xuICAgIGNvbnN0IHsgZGF0YTogcGVkaWRvLCBlcnJvcjogcGVkaWRvRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInBlZGlkb3NcIilcbiAgICAgIC5pbnNlcnQoW1xuICAgICAgICB7XG4gICAgICAgICAgY2xpZW50ZV9pZDogY2xpZW50ZUlkLCAvLyBJRCBkbyB1c3XDoXJpbyBxdWUgZmV6IGEgY29tcHJhXG4gICAgICAgICAgcmV2ZW5kZWRvcl9pZDogcmV2ZW5kZWRvclVzdWFyaW9JZCwgLy8gSUQgZG8gdXN1w6FyaW8gcmV2ZW5kZWRvciAoZGEgdGFiZWxhIHVzdWFyaW9zKVxuICAgICAgICAgIG51bWVybzogbnVtZXJvUGVkaWRvLFxuICAgICAgICAgIGZyZXRlOiBmcmV0ZSxcbiAgICAgICAgICB2YWxvcl90b3RhbDogdmFsb3JUb3RhbCxcbiAgICAgICAgICBwYWdhbWVudG9fdGlwbzogbWV0b2RvUGFnYW1lbnRvLFxuICAgICAgICAgIHRpcG9fZW50cmVnYTogdGlwb0VudHJlZ2EsXG4gICAgICAgICAgc3RhdHVzOiBcInBhZ29cIiwgLy8gU3RhdHVzIGRlIHBhZ2FtZW50b1xuICAgICAgICAgIHN0YXR1c19kZXRhbGhhZG86IHN0YXR1c0luaWNpYWwsIC8vIFN0YXR1cyBkZXRhbGhhZG8gYmFzZWFkbyBubyB0aXBvIGRlIGVudHJlZ2FcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgXSlcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAocGVkaWRvRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGNyaWFyIHBlZGlkbzpcIiwgcGVkaWRvRXJyb3IpXG4gICAgICB0aHJvdyBwZWRpZG9FcnJvclxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiUGVkaWRvIGNyaWFkbyBjb20gc3VjZXNzbzpcIiwgcGVkaWRvKVxuXG4gICAgLy8gUmVnaXN0cmFyIG8gc3RhdHVzIGluaWNpYWwgbm8gaGlzdMOzcmljb1xuICAgIGF3YWl0IHJlZ2lzdHJhck11ZGFuY2FTdGF0dXMocGVkaWRvLmlkLCBudWxsLCBzdGF0dXNJbmljaWFsLCBcIlBlZGlkbyBjcmlhZG9cIiwgbnVsbClcblxuICAgIC8vIFByZXBhcmFyIGl0ZW5zIHBhcmEgaW5zZXLDp8OjbyBjb20gcGFjb3RlX2lkIGNvcnJldG8gcGFyYSBjYWRhIGl0ZW1cbiAgICBjb25zdCBpdGVuc1BhcmFJbnNlcmlyID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBpdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIEJ1c2NhciBvIHBhY290ZV9pZCBjb3JyZXRvIGJhc2VhZG8gbm8gbm9tZSBkbyBwcm9kdXRvXG4gICAgICAgIGNvbnN0IHsgZGF0YTogcGFjb3RlSWQgfSA9IGF3YWl0IGdldFBhY290ZUJ5UHJvZHV0b05vbWUoaXRlbS5ub21lKVxuXG4gICAgICAgIGNvbnN0IGl0ZW1QYXJhSW5zZXJpciA9IHtcbiAgICAgICAgICBwZWRpZG9faWQ6IHBlZGlkby5pZCxcbiAgICAgICAgICBwYWNvdGVfaWQ6IHBhY290ZUlkLFxuICAgICAgICAgIHF0ZDogTnVtYmVyKGl0ZW0ucXVhbnRpZGFkZSkgfHwgMCxcbiAgICAgICAgICB2YWxvcl91bml0YXJpbzogTnVtYmVyKGl0ZW0ucHJlY28pIHx8IDAsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhgSXRlbSAke2luZGV4ICsgMX0gcHJlcGFyYWRvOmAsIGl0ZW1QYXJhSW5zZXJpcilcbiAgICAgICAgY29uc29sZS5sb2coYFByb2R1dG86ICR7aXRlbS5ub21lfSAtPiBQYWNvdGUgSUQ6ICR7cGFjb3RlSWR9YClcbiAgICAgICAgcmV0dXJuIGl0ZW1QYXJhSW5zZXJpclxuICAgICAgfSksXG4gICAgKVxuXG4gICAgY29uc29sZS5sb2coXCJUb2RvcyBvcyBpdGVucyBwcmVwYXJhZG9zOlwiLCBpdGVuc1BhcmFJbnNlcmlyKVxuXG4gICAgLy8gSW5zZXJpciBvcyBpdGVucyBkbyBwZWRpZG9cbiAgICBjb25zdCB7IGRhdGE6IGl0ZW5zSW5zZXJpZG9zLCBlcnJvcjogaXRlbnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwicGVkaWRvX2l0ZW5zXCIpXG4gICAgICAuaW5zZXJ0KGl0ZW5zUGFyYUluc2VyaXIpXG4gICAgICAuc2VsZWN0KClcblxuICAgIGlmIChpdGVuc0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBkZXRhbGhhZG8gYW8gaW5zZXJpciBpdGVucyBkbyBwZWRpZG86XCIsIGl0ZW5zRXJyb3IpXG4gICAgICBjb25zb2xlLmVycm9yKFwiRGFkb3MgcXVlIHRlbnRhbW9zIGluc2VyaXI6XCIsIGl0ZW5zUGFyYUluc2VyaXIpXG4gICAgICB0aHJvdyBpdGVuc0Vycm9yXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJJdGVucyBpbnNlcmlkb3MgY29tIHN1Y2Vzc286XCIsIGl0ZW5zSW5zZXJpZG9zKVxuXG4gICAgcmV0dXJuIHsgZGF0YTogcGVkaWRvLCBlcnJvcjogbnVsbCB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gY3JpYXIgcGVkaWRvOlwiLCBlcnJvcilcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIH1cbn1cblxuLy8gRnVuw6fDo28gcGFyYSBhdHVhbGl6YXIgc3RhdHVzIGRvIHBlZGlkb1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF0dWFsaXphclN0YXR1c1BlZGlkbyhcbiAgcGVkaWRvSWQ6IG51bWJlcixcbiAgbm92b1N0YXR1czogc3RyaW5nLFxuICBkYXRhRXN0aW1hZGE/OiBzdHJpbmcsXG4gIG9ic2VydmFjb2VzPzogc3RyaW5nLFxuICB1cGRhdGVkQnk/OiBudW1iZXIsXG4pIHtcbiAgdHJ5IHtcbiAgICAvLyBQcmltZWlybywgYnVzY2FyIG8gc3RhdHVzIGF0dWFsXG4gICAgY29uc3QgeyBkYXRhOiBwZWRpZG9BdHVhbCwgZXJyb3I6IGVycm9yQnVzY2EgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInBlZGlkb3NcIilcbiAgICAgIC5zZWxlY3QoXCJzdGF0dXNfZGV0YWxoYWRvXCIpXG4gICAgICAuZXEoXCJpZFwiLCBwZWRpZG9JZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yQnVzY2EpIHtcbiAgICAgIHRocm93IGVycm9yQnVzY2FcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJhciBkYWRvcyBwYXJhIGF0dWFsaXphw6fDo29cbiAgICBjb25zdCBkYWRvc0F0dWFsaXphY2FvOiBhbnkgPSB7XG4gICAgICBzdGF0dXNfZGV0YWxoYWRvOiBub3ZvU3RhdHVzLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cblxuICAgIGlmIChkYXRhRXN0aW1hZGEpIHtcbiAgICAgIGRhZG9zQXR1YWxpemFjYW8uZGF0YV9lc3RpbWFkYV9lbnRyZWdhID0gZGF0YUVzdGltYWRhXG4gICAgfVxuXG4gICAgaWYgKG9ic2VydmFjb2VzKSB7XG4gICAgICBkYWRvc0F0dWFsaXphY2FvLm9ic2VydmFjb2VzX3JldmVuZGVkb3IgPSBvYnNlcnZhY29lc1xuICAgIH1cblxuICAgIC8vIFNlIG8gc3RhdHVzIGZvciBcImVudHJlZ3VlXCIgb3UgXCJyZXRpcmFkb1wiLCBkZWZpbmlyIGRhdGEgcmVhbFxuICAgIGlmIChub3ZvU3RhdHVzID09PSBcImVudHJlZ3VlXCIgfHwgbm92b1N0YXR1cyA9PT0gXCJyZXRpcmFkb1wiKSB7XG4gICAgICBkYWRvc0F0dWFsaXphY2FvLmRhdGFfZW50cmVnYV9yZWFsID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfVxuXG4gICAgLy8gQXR1YWxpemFyIG8gcGVkaWRvXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInBlZGlkb3NcIikudXBkYXRlKGRhZG9zQXR1YWxpemFjYW8pLmVxKFwiaWRcIiwgcGVkaWRvSWQpLnNlbGVjdCgpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgLy8gUmVnaXN0cmFyIG11ZGFuw6dhIG5vIGhpc3TDs3JpY29cbiAgICBhd2FpdCByZWdpc3RyYXJNdWRhbmNhU3RhdHVzKHBlZGlkb0lkLCBwZWRpZG9BdHVhbC5zdGF0dXNfZGV0YWxoYWRvLCBub3ZvU3RhdHVzLCBvYnNlcnZhY29lcywgdXBkYXRlZEJ5KVxuXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGF0dWFsaXphciBzdGF0dXMgZG8gcGVkaWRvOlwiLCBlcnJvcilcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlZGlkb3ModXNlcklkOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInBlZGlkb3NcIilcbiAgICAuc2VsZWN0KGBcbiAgICAgICosXG4gICAgICBpdGVuc19wZWRpZG86aXRlbnNfcGVkaWRvKFxuICAgICAgICAqLFxuICAgICAgICBwcm9kdXRvOnByb2R1dG9zKCopXG4gICAgICApXG4gICAgYClcbiAgICAuZXEoXCJ1c2VyX2lkXCIsIHVzZXJJZClcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbn1cblxuLy8gU3Vic3RpdHVpciBhIGZ1bsOnw6NvIGdldFBlZGlkb3NDbGllbnRlIHBvciBlc3RhIHZlcnPDo28gY29ycmlnaWRhOlxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlZGlkb3NDbGllbnRlKHVzZXJJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coXCJCdXNjYW5kbyBwZWRpZG9zIHBhcmEgdXN1w6FyaW86XCIsIHVzZXJJZClcblxuICAgIC8vIENvbnZlcnRlciB1c2VySWQgcGFyYSBuw7ptZXJvXG4gICAgY29uc3QgY2xpZW50ZUlkID0gTnVtYmVyLnBhcnNlSW50KHVzZXJJZClcblxuICAgIC8vIEJ1c2NhciBwZWRpZG9zIHVzYW5kbyBvIGNsaWVudGVfaWQgZGlyZXRhbWVudGVcbiAgICBjb25zdCB7IGRhdGE6IHBlZGlkb3MsIGVycm9yOiBwZWRpZG9zRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInBlZGlkb3NcIilcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBwZWRpZG9faXRlbnM6cGVkaWRvX2l0ZW5zKFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBlZGlkb19pZCxcbiAgICAgICAgICBwYWNvdGVfaWQsXG4gICAgICAgICAgcXRkLFxuICAgICAgICAgIHZhbG9yX3VuaXRhcmlvLFxuICAgICAgICAgIHBhY290ZXM6cGFjb3RlcyhpZCwgbm9tZSwgY29yLCBpbWFnZW0pXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoXCJjbGllbnRlX2lkXCIsIGNsaWVudGVJZCkgLy8gQ29ycmlnaWRvOiBjbGllbnRlX2lkIGVtIHZleiBkZSBjbGllbnRfaWRcbiAgICAgIC5vcmRlcihcImNyZWF0ZWRfYXRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBjb25zb2xlLmxvZyhcIlBlZGlkb3MgZW5jb250cmFkb3M6XCIsIHBlZGlkb3M/Lmxlbmd0aCB8fCAwKVxuXG4gICAgaWYgKHBlZGlkb3NFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gYnVzY2FyIHBlZGlkb3M6XCIsIHBlZGlkb3NFcnJvcilcbiAgICAgIHRocm93IHBlZGlkb3NFcnJvclxuICAgIH1cblxuICAgIHJldHVybiB7IGRhdGE6IHBlZGlkb3MgfHwgW10sIGVycm9yOiBudWxsIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgcGVkaWRvcyBkbyBjbGllbnRlOlwiLCBlcnJvcilcbiAgICByZXR1cm4geyBkYXRhOiBbXSwgZXJyb3IgfVxuICB9XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgYnVzY2FyIHRhbWFuaG9zIGRlIHJvZGFzIGRpc3BvbsOtdmVpc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhbWFuaG9zKCkge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidGFtYW5ob3NcIikuc2VsZWN0KFwiaWQsIG5vbWVcIikub3JkZXIoXCJub21lXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIGJ1c2NhciBhbHR1cmFzIGRpc3BvbsOtdmVpcyBjb20gYmFzZSBubyB0YW1hbmhvIGRhIHJvZGFcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbHR1cmFzQnlUYW1hbmhvSWQodGFtYW5ob0lkOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImFsdHVyYXNcIilcbiAgICAuc2VsZWN0KFwiaWQsIHZhbG9yXCIpXG4gICAgLmVxKFwidGFtYW5ob19pZFwiLCB0YW1hbmhvSWQpXG4gICAgLm9yZGVyKFwidmFsb3JcIiwgeyBhc2NlbmRpbmc6IHRydWUgfSlcblxuICAvLyBSZW1vdmVyIGR1cGxpY2F0YXMgYmFzZWFkbyBubyB2YWxvclxuICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB1bmlxdWVBbHR1cmFzID0gZGF0YS5yZWR1Y2UoKGFjYzogYW55W10sIGN1cnJlbnQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0cyA9IGFjYy5maW5kKGl0ZW0gPT4gaXRlbS52YWxvciA9PT0gY3VycmVudC52YWxvcilcbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIGFjYy5wdXNoKGN1cnJlbnQpXG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgW10pXG4gICAgXG4gICAgcmV0dXJuIHsgZGF0YTogdW5pcXVlQWx0dXJhcywgZXJyb3IgfVxuICB9XG5cbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIGJ1c2NhciBsYXJndXJhcyBiYXNlZCBvbiBhbHR1cmFfaWRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMYXJndXJhc0J5QWx0dXJhSWQoYWx0dXJhSWQ6IHN0cmluZykge1xuICBjb25zb2xlLmxvZyhcIvCflI0gQnVzY2FuZG8gbGFyZ3VyYXMgcGFyYSBhbHR1cmFJZDpcIiwgYWx0dXJhSWQpXG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwibGFyZ3VyYXNcIilcbiAgICAuc2VsZWN0KFwiaWQsIHZhbG9yXCIpXG4gICAgLmVxKFwiYWx0dXJhX2lkXCIsIGFsdHVyYUlkKVxuICAgIC5vcmRlcihcInZhbG9yXCIsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgLy8gUmVtb3ZlciBkdXBsaWNhdGFzIGJhc2VhZG8gbm8gdmFsb3JcbiAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdW5pcXVlTGFyZ3VyYXMgPSBkYXRhLnJlZHVjZSgoYWNjOiBhbnlbXSwgY3VycmVudCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RzID0gYWNjLmZpbmQoaXRlbSA9PiBpdGVtLnZhbG9yID09PSBjdXJyZW50LnZhbG9yKVxuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgYWNjLnB1c2goY3VycmVudClcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCBbXSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIvCfk48gTGFyZ3VyYXMgw7puaWNhcyBlbmNvbnRyYWRhczpcIiwgeyBkYXRhOiB1bmlxdWVMYXJndXJhcywgZXJyb3IgfSlcbiAgICByZXR1cm4geyBkYXRhOiB1bmlxdWVMYXJndXJhcywgZXJyb3IgfVxuICB9XG5cbiAgY29uc29sZS5sb2coXCLwn5OPIExhcmd1cmFzIGVuY29udHJhZGFzOlwiLCB7IGRhdGEsIGVycm9yIH0pXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbn1cblxuLy8gRnVuw6fDo28gcGFyYSBidXNjYXIgcGFja2FnZSBkZXRhaWxzIGJ5IGxhcmd1cmFfaWRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYWNvdGVCeUxhcmd1cmFJZChsYXJndXJhSWQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwi8J+UjSBCdXNjYW5kbyBwYWNvdGUgcGFyYSBsYXJndXJhSWQ6XCIsIGxhcmd1cmFJZClcbiAgICBcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwicGFjb3Rlc1wiKS5zZWxlY3QoXCIqXCIpLmVxKFwibGFyZ3VyYV9pZFwiLCBsYXJndXJhSWQpLnNpbmdsZSgpXG5cbiAgICBjb25zb2xlLmxvZyhcIvCfk6YgUmVzdWx0YWRvIGRhIGJ1c2NhOlwiLCB7IGRhdGEsIGVycm9yIH0pXG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm8gYW8gYnVzY2FyIHBhY290ZSBwb3IgbGFyZ3VyYV9pZDpcIiwgZXJyb3IpXG4gICAgICAvLyBGYWxsYmFjazogcmV0b3JuYXIgdW0gcGFjb3RlIHBhZHLDo29cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogMSxcbiAgICAgICAgICBub21lOiBcIkxUUDYwXCIsXG4gICAgICAgICAgY29yOiBcIiM0QTQ5NTNcIixcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIk5lbmh1bSBwYWNvdGUgZW5jb250cmFkbyBwYXJhIGxhcmd1cmFfaWQ6XCIsIGxhcmd1cmFJZClcbiAgICAgIC8vIEZhbGxiYWNrOiByZXRvcm5hciB1bSBwYWNvdGUgcGFkcsOjb1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgIG5vbWU6IFwiTFRQNjBcIixcbiAgICAgICAgICBjb3I6IFwiIzRBNDk1M1wiLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBanVzdGFyIGRhZG9zIHNlIG5vbWUgZXN0aXZlciBudWxsXG4gICAgY29uc3QgcGFjb3RlQWp1c3RhZG8gPSB7XG4gICAgICBpZDogZGF0YS5pZCxcbiAgICAgIG5vbWU6IGRhdGEubm9tZSB8fCBkYXRhLmRlc2NyaWNhbyB8fCBcIkxUUDYwXCIsXG4gICAgICBjb3I6IGRhdGEuY29yIHx8IFwiIzk0OTY5OFwiIC8vIENvciBwYWRyw6NvIGJhc2VhZGEgbm9zIGRhZG9zIGV4aXN0ZW50ZXNcbiAgICB9XG5cbiAgICByZXR1cm4geyBkYXRhOiBwYWNvdGVBanVzdGFkbywgZXJyb3I6IG51bGwgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGJ1c2NhciBwYWNvdGU6XCIsIGVycm9yKVxuICAgIC8vIEZhbGxiYWNrOiByZXRvcm5hciB1bSBwYWNvdGUgcGFkcsOjb1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBub21lOiBcIkxUUDYwXCIsXG4gICAgICAgIGNvcjogXCIjNEE0OTUzXCIsXG4gICAgICB9LFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfVxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09IEZVTsOHw5VFUyBETyBDQVJSSU5ITyA9PT09PT09PT09PT09PT09PT09PVxuXG4vLyBCdXNjYXIgY2FycmluaG8gZG8gdXN1w6FyaW9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYXJyaW5ob1VzdWFyaW8odXNlcklkOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImNhcnJpbmhvX3VzdWFyaW9zXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJ1c2VyX2lkXCIsIHVzZXJJZClcbiAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gIHJldHVybiB7IGRhdGEsIGVycm9yIH1cbn1cblxuLy8gQWRpY2lvbmFyIGl0ZW0gYW8gY2FycmluaG9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGljaW9uYXJJdGVtQ2FycmluaG8odXNlcklkOiBzdHJpbmcsIHByb2R1dG9Ob21lOiBzdHJpbmcsIHF1YW50aWRhZGUgPSA1LCBpbWFnZW0/OiBzdHJpbmcpIHtcbiAgLy8gRW5zdXJlIHF1YW50aXR5IGlzIGEgbXVsdGlwbGUgb2YgNSBhbmQgYXQgbGVhc3QgNVxuICBjb25zdCBhZGp1c3RlZFF1YW50aXR5ID0gTWF0aC5tYXgoTWF0aC5yb3VuZChxdWFudGlkYWRlIC8gNSkgKiA1LCA1KVxuXG4gIC8vIFZlcmlmaWNhciBzZSBvIGl0ZW0gasOhIGV4aXN0ZSBubyBjYXJyaW5ob1xuICBjb25zdCB7IGRhdGE6IGl0ZW1FeGlzdGVudGUsIGVycm9yOiBlcnJvckJ1c2NhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiY2FycmluaG9fdXN1YXJpb3NcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcInVzZXJfaWRcIiwgdXNlcklkKVxuICAgIC5lcShcInByb2R1dG9fbm9tZVwiLCBwcm9kdXRvTm9tZSlcbiAgICAuc2luZ2xlKClcblxuICBpZiAoZXJyb3JCdXNjYSAmJiBlcnJvckJ1c2NhLmNvZGUgIT09IFwiUEdSU1QxMTZcIikge1xuICAgIC8vIFBHUlNUMTE2ID0gTm8gcm93cyBmb3VuZCAoZXNwZXJhZG8gc2UgaXRlbSBuw6NvIGV4aXN0ZSlcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZXJyb3JCdXNjYSB9XG4gIH1cblxuICBpZiAoaXRlbUV4aXN0ZW50ZSkge1xuICAgIC8vIEl0ZW0gasOhIGV4aXN0ZSwgYWRpY2lvbmFyIDUgdW5pZGFkZXNcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJjYXJyaW5ob191c3Vhcmlvc1wiKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIHF1YW50aWRhZGU6IGl0ZW1FeGlzdGVudGUucXVhbnRpZGFkZSArIDUsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pXG4gICAgICAuZXEoXCJpZFwiLCBpdGVtRXhpc3RlbnRlLmlkKVxuICAgICAgLnNlbGVjdCgpXG5cbiAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlbSBuw6NvIGV4aXN0ZSwgY3JpYXIgbm92byBjb20gcXVhbnRpZGFkZSBhanVzdGFkYVxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImNhcnJpbmhvX3VzdWFyaW9zXCIpXG4gICAgICAuaW5zZXJ0KFtcbiAgICAgICAge1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBwcm9kdXRvX25vbWU6IHByb2R1dG9Ob21lLFxuICAgICAgICAgIHF1YW50aWRhZGU6IGFkanVzdGVkUXVhbnRpdHksXG4gICAgICAgICAgaW1hZ2VtOiBpbWFnZW0sXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICAgLnNlbGVjdCgpXG5cbiAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG4gIH1cbn1cblxuLy8gQXR1YWxpemFyIHF1YW50aWRhZGUgZGUgaXRlbSBubyBjYXJyaW5ob1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF0dWFsaXphclF1YW50aWRhZGVDYXJyaW5obyh1c2VySWQ6IHN0cmluZywgcHJvZHV0b05vbWU6IHN0cmluZywgcXVhbnRpZGFkZTogbnVtYmVyKSB7XG4gIC8vIEVuc3VyZSBxdWFudGl0eSBpcyBhIG11bHRpcGxlIG9mIDUgYW5kIGF0IGxlYXN0IDVcbiAgY29uc3QgYWRqdXN0ZWRRdWFudGl0eSA9IE1hdGgubWF4KE1hdGgucm91bmQocXVhbnRpZGFkZSAvIDUpICogNSwgNSlcblxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiY2FycmluaG9fdXN1YXJpb3NcIilcbiAgICAudXBkYXRlKHtcbiAgICAgIHF1YW50aWRhZGU6IGFkanVzdGVkUXVhbnRpdHksXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSlcbiAgICAuZXEoXCJ1c2VyX2lkXCIsIHVzZXJJZClcbiAgICAuZXEoXCJwcm9kdXRvX25vbWVcIiwgcHJvZHV0b05vbWUpXG4gICAgLnNlbGVjdCgpXG5cbiAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxufVxuXG4vLyBSZW1vdmVyIGl0ZW0gZG8gY2FycmluaG9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVySXRlbUNhcnJpbmhvKHVzZXJJZDogc3RyaW5nLCBwcm9kdXRvTm9tZTogc3RyaW5nKSB7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJjYXJyaW5ob191c3Vhcmlvc1wiKVxuICAgIC5kZWxldGUoKVxuICAgIC5lcShcInVzZXJfaWRcIiwgdXNlcklkKVxuICAgIC5lcShcInByb2R1dG9fbm9tZVwiLCBwcm9kdXRvTm9tZSlcblxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG59XG5cbi8vIExpbXBhciBjYXJyaW5obyBkbyB1c3XDoXJpb1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpbXBhckNhcnJpbmhvVXN1YXJpbyh1c2VySWQ6IHN0cmluZykge1xuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiY2FycmluaG9fdXN1YXJpb3NcIikuZGVsZXRlKCkuZXEoXCJ1c2VyX2lkXCIsIHVzZXJJZClcblxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG59XG5cbi8vIEF0dWFsaXphciBjYXJyaW5obyBjb21wbGV0byBkbyB1c3XDoXJpb1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF0dWFsaXphckNhcnJpbmhvVXN1YXJpbyh1c2VySWQ6IHN0cmluZywgaXRlbXM6IGFueVtdKSB7XG4gIHRyeSB7XG4gICAgLy8gUHJpbWVpcm8sIGxpbXBhciBvIGNhcnJpbmhvIGF0dWFsXG4gICAgYXdhaXQgbGltcGFyQ2FycmluaG9Vc3VhcmlvKHVzZXJJZClcbiAgICBcbiAgICAvLyBTZSBuw6NvIGjDoSBpdGVucywgYXBlbmFzIHJldG9ybmFyIHN1Y2Vzc29cbiAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJbnNlcmlyIHRvZG9zIG9zIG5vdm9zIGl0ZW5zXG4gICAgY29uc3QgaXRlbnNQYXJhSW5zZXJpciA9IGl0ZW1zLm1hcChpdGVtID0+ICh7XG4gICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICBwcm9kdXRvX25vbWU6IGl0ZW0ubm9tZSxcbiAgICAgIHF1YW50aWRhZGU6IGl0ZW0ucXVhbnRpZGFkZSxcbiAgICAgIGltYWdlbTogaXRlbS5pbWFnZW0sXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9KSlcbiAgICBcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJjYXJyaW5ob191c3Vhcmlvc1wiKVxuICAgICAgLmluc2VydChpdGVuc1BhcmFJbnNlcmlyKVxuICAgICAgLnNlbGVjdCgpXG4gICAgXG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGF0dWFsaXphciBjYXJyaW5obzpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09IEZVTsOHw5VFUyBERSBSRVZFTkRFRE9SRVMgRSBFU1RPUVVFID09PT09PT09PT09PT09PT09PT09XG5cbi8vIEJ1c2NhciByZXZlbmRlZG9yZXMgcXVlIHBvc3N1ZW0gdW0gcHJvZHV0byBlc3BlY8OtZmljbyBlbSBlc3RvcXVlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmV2ZW5kZWRvcmVzQ29tUHJvZHV0byhwcm9kdXRvTm9tZTogc3RyaW5nKSB7XG4gIC8vIFVzYW5kbyBKT0lOIG1hbnVhbCBlbSB2ZXogZGUgcmVsYWNpb25hbWVudG9cbiAgY29uc3QgeyBkYXRhOiBlc3RvcXVlLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInJldmVuZGVkb3JfZXN0b3F1ZVwiKVxuICAgIC5zZWxlY3QoYFxuICAgICAgaWQsXG4gICAgICByZXZlbmRlZG9yX2lkLFxuICAgICAgcHJvZHV0byxcbiAgICAgIHF1YW50aWRhZGUsXG4gICAgICBwcmVjbyxcbiAgICAgIHN0YXR1c1xuICAgIGApXG4gICAgLmVxKFwicHJvZHV0b1wiLCBwcm9kdXRvTm9tZSlcbiAgICAuZ3QoXCJxdWFudGlkYWRlXCIsIDApIC8vIEFwZW5hcyBjb20gZXN0b3F1ZSBkaXNwb27DrXZlbFxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgfVxuXG4gIC8vIEJ1c2NhciBpbmZvcm1hw6fDtWVzIGRvcyByZXZlbmRlZG9yZXNcbiAgY29uc3QgcmV2ZW5kZWRvcklkcyA9IGVzdG9xdWU/Lm1hcCgoaXRlbSkgPT4gaXRlbS5yZXZlbmRlZG9yX2lkKSB8fCBbXVxuXG4gIGlmIChyZXZlbmRlZG9ySWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9XG4gIH1cblxuICBjb25zdCB7IGRhdGE6IHJldmVuZGVkb3JlcywgZXJyb3I6IHJldmVuZGVkb3Jlc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmV2ZW5kZWRvcmVzXCIpXG4gICAgLnNlbGVjdChgXG4gICAgICBpZCxcbiAgICAgIHVzdWFyaW9faWQsXG4gICAgICBsb2phLFxuICAgICAgY2lkYWRlLFxuICAgICAgdWYsXG4gICAgICBmcmV0ZSxcbiAgICAgIHZlbmRhcyxcbiAgICAgIHN0YXR1c1xuICAgIGApXG4gICAgLmluKFwiaWRcIiwgcmV2ZW5kZWRvcklkcylcblxuICBpZiAocmV2ZW5kZWRvcmVzRXJyb3IpIHtcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogcmV2ZW5kZWRvcmVzRXJyb3IgfVxuICB9XG5cbiAgLy8gQ29tYmluYXIgb3MgZGFkb3NcbiAgY29uc3QgcmVzdWx0YWRvID1cbiAgICBlc3RvcXVlXG4gICAgICA/Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCByZXZlbmRlZG9yID0gcmV2ZW5kZWRvcmVzPy5maW5kKChyKSA9PiByLmlkID09PSBpdGVtLnJldmVuZGVkb3JfaWQpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICByZXZlbmRlZG9yOiByZXZlbmRlZG9yIHx8IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnJldmVuZGVkb3IgIT09IG51bGwpIHx8IFtdXG5cbiAgLy8gT3JkZW5hciBwb3IgcHJlw6dvXG4gIHJlc3VsdGFkby5zb3J0KChhLCBiKSA9PiBhLnByZWNvIC0gYi5wcmVjbylcblxuICByZXR1cm4geyBkYXRhOiByZXN1bHRhZG8sIGVycm9yOiBudWxsIH1cbn1cblxuLy8gQnVzY2FyIHJldmVuZGVkb3JlcyBwYXJhIG3Dumx0aXBsb3MgcHJvZHV0b3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZXZlbmRlZG9yZXNQYXJhUHJvZHV0b3MocHJvZHV0b05vbWVzOiBzdHJpbmdbXSkge1xuICBpZiAoIXByb2R1dG9Ob21lcy5sZW5ndGgpIHJldHVybiB7IGRhdGE6IHt9LCBlcnJvcjogbnVsbCB9XG5cbiAgLy8gQnVzY2FyIHRvZG9zIG9zIHByb2R1dG9zIGRlIHVtYSB2ZXpcbiAgY29uc3QgeyBkYXRhOiBlc3RvcXVlLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInJldmVuZGVkb3JfZXN0b3F1ZVwiKVxuICAgIC5zZWxlY3QoYFxuICAgICAgaWQsXG4gICAgICByZXZlbmRlZG9yX2lkLFxuICAgICAgcHJvZHV0byxcbiAgICAgIHF1YW50aWRhZGUsXG4gICAgICBwcmVjbyxcbiAgICAgIHN0YXR1c1xuICAgIGApXG4gICAgLmluKFwicHJvZHV0b1wiLCBwcm9kdXRvTm9tZXMpXG4gICAgLmd0KFwicXVhbnRpZGFkZVwiLCAwKSAvLyBBcGVuYXMgY29tIGVzdG9xdWUgZGlzcG9uw612ZWxcblxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBkYXRhOiB7fSwgZXJyb3IgfVxuICB9XG5cbiAgaWYgKCFlc3RvcXVlIHx8IGVzdG9xdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgZGF0YToge30sIGVycm9yOiBudWxsIH1cbiAgfVxuXG4gIC8vIEJ1c2NhciBpbmZvcm1hw6fDtWVzIGRvcyByZXZlbmRlZG9yZXNcbiAgY29uc3QgcmV2ZW5kZWRvcklkcyA9IFsuLi5uZXcgU2V0KGVzdG9xdWUubWFwKChpdGVtKSA9PiBpdGVtLnJldmVuZGVkb3JfaWQpKV1cblxuICBjb25zdCB7IGRhdGE6IHJldmVuZGVkb3JlcywgZXJyb3I6IHJldmVuZGVkb3Jlc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmV2ZW5kZWRvcmVzXCIpXG4gICAgLnNlbGVjdChgXG4gICAgICBpZCxcbiAgICAgIHVzdWFyaW9faWQsXG4gICAgICBsb2phLFxuICAgICAgY2lkYWRlLFxuICAgICAgdWYsXG4gICAgICBmcmV0ZSxcbiAgICAgIHZlbmRhcyxcbiAgICAgIHN0YXR1c1xuICAgIGApXG4gICAgLmluKFwiaWRcIiwgcmV2ZW5kZWRvcklkcylcblxuICBpZiAocmV2ZW5kZWRvcmVzRXJyb3IpIHtcbiAgICByZXR1cm4geyBkYXRhOiB7fSwgZXJyb3I6IHJldmVuZGVkb3Jlc0Vycm9yIH1cbiAgfVxuXG4gIC8vIENvbWJpbmFyIG9zIGRhZG9zIGUgYWdydXBhciBwb3IgcHJvZHV0b1xuICBjb25zdCBwcm9kdXRvc0FncnVwYWRvczogUmVjb3JkPHN0cmluZywgYW55W10+ID0ge31cblxuICBwcm9kdXRvTm9tZXMuZm9yRWFjaCgocHJvZHV0b05vbWUpID0+IHtcbiAgICBjb25zdCBwcm9kdXRvRXN0b3F1ZSA9IGVzdG9xdWVcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0ucHJvZHV0byA9PT0gcHJvZHV0b05vbWUpXG4gICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHJldmVuZGVkb3IgPSByZXZlbmRlZG9yZXM/LmZpbmQoKHIpID0+IHIuaWQgPT09IGl0ZW0ucmV2ZW5kZWRvcl9pZClcbiAgICAgICAgcmV0dXJuIHJldmVuZGVkb3IgPyB7IC4uLml0ZW0sIHJldmVuZGVkb3IgfSA6IG51bGxcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtICE9PSBudWxsKVxuXG4gICAgLy8gT3JkZW5hciBwb3IgcHJlw6dvXG4gICAgcHJvZHV0b0VzdG9xdWUuc29ydCgoYSwgYikgPT4gYS5wcmVjbyAtIGIucHJlY28pXG5cbiAgICBwcm9kdXRvc0FncnVwYWRvc1twcm9kdXRvTm9tZV0gPSBwcm9kdXRvRXN0b3F1ZVxuICB9KVxuXG4gIHJldHVybiB7IGRhdGE6IHByb2R1dG9zQWdydXBhZG9zLCBlcnJvcjogbnVsbCB9XG59XG5cbi8vIEJ1c2NhciBpbmZvcm1hw6fDtWVzIGRvIHVzdcOhcmlvXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckluZm8odXNlcklkOiBzdHJpbmcpIHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInVzdWFyaW9zXCIpXG4gICAgLnNlbGVjdChcImlkLCBub21lLCBlbWFpbCwgY2lkYWRlLCB1ZiwgY2VwLCBydWEsIGJhaXJybywgY29tcGxlbWVudG8sIG51bWVyb1wiKVxuICAgIC5lcShcImlkXCIsIHVzZXJJZClcbiAgICAuc2luZ2xlKClcblxuICByZXR1cm4geyBkYXRhLCBlcnJvciB9XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgYnVzY2FyIHVzdWFyaW9faWQgZG8gcmV2ZW5kZWRvciBiYXNlYWRvIG5vIHJldmVuZGVkb3JfaWRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc3VhcmlvSWRSZXZlbmRlZG9yKHJldmVuZGVkb3JJZDogbnVtYmVyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInJldmVuZGVkb3Jlc1wiKS5zZWxlY3QoXCJ1c3VhcmlvX2lkXCIpLmVxKFwiaWRcIiwgcmV2ZW5kZWRvcklkKS5zaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgdXN1YXJpb19pZCBkbyByZXZlbmRlZG9yOlwiLCBlcnJvcilcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBkYXRhOiBkYXRhLnVzdWFyaW9faWQsIGVycm9yOiBudWxsIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgdXN1YXJpb19pZCBkbyByZXZlbmRlZG9yOlwiLCBlcnJvcilcbiAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsImdldFByb2R1dG9zIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiZ2V0UHJvZHV0byIsImlkIiwiZXEiLCJzaW5nbGUiLCJzYWx2YXJDYWxjdWxvIiwidGFtYW5ob1JvZGEiLCJhbHR1cmEiLCJsYXJndXJhIiwicmVzdWx0YWRvIiwiY29yIiwiaW5zZXJ0IiwidGFtYW5ob19yb2RhIiwic2FsdmFyQ2FsY3Vsb1VzdWFyaW8iLCJ1c2VySWQiLCJ0YW1hbmhvIiwicGFjb3RlIiwiY2FsY3Vsb3MiLCJjb250YXJFcnJvciIsImNvbnNvbGUiLCJsZW5ndGgiLCJjYWxjdWxvTWFpc0FudGlnbyIsImRlbGV0ZUVycm9yIiwiZGVsZXRlIiwidXNlcmlkIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJnZXRDYWxjdWxvc1VzdWFyaW8iLCJnZXRDYWxjdWxvcyIsImNyaWFyUGVkaWRvIiwiaXRlbXMiLCJ0b3RhbCIsInRpcG9FbnRyZWdhIiwibWV0b2RvUGFnYW1lbnRvIiwiZGFkb3NBZGljaW9uYWlzIiwicGVkaWRvIiwicGVkaWRvRXJyb3IiLCJ1c2VyX2lkIiwidGlwb19lbnRyZWdhIiwicGFnYW1lbnRvX3RpcG8iLCJzdGF0dXMiLCJkYWRvc19hZGljaW9uYWlzIiwiaXRlbnMiLCJtYXAiLCJpdGVtIiwicGVkaWRvX2lkIiwicHJvZHV0b19ub21lIiwibm9tZSIsInF1YW50aWRhZGUiLCJwcmVjb191bml0YXJpbyIsInByZWNvIiwicmV2ZW5kZWRvcl9pZCIsIml0ZW5zRXJyb3IiLCJnZXRQYWNvdGVCeVByb2R1dG9Ob21lIiwicHJvZHV0b05vbWUiLCJtYXBlYW1lbnRvUHJvZHV0b3MiLCJwYWNvdGVzIiwiaWxpa2UiLCJsaW1pdCIsImNvcmVzIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInBhY290ZVBvckNvciIsImVycm9yQ29yIiwiZ2V0UGFjb3RlVmFsaWRvIiwicmVnaXN0cmFyTXVkYW5jYVN0YXR1cyIsInBlZGlkb0lkIiwic3RhdHVzQW50ZXJpb3IiLCJzdGF0dXNOb3ZvIiwib2JzZXJ2YWNhbyIsInVwZGF0ZWRCeSIsInN0YXR1c19hbnRlcmlvciIsInN0YXR1c19ub3ZvIiwidXBkYXRlZF9ieSIsImNyaWFyUGVkaWRvTm92byIsInJldmVuZGVkb3JJZCIsInZhbG9yVG90YWwiLCJmcmV0ZSIsImxvZyIsImNsaWVudGVJZCIsIk51bWJlciIsInBhcnNlSW50IiwicmV2ZW5kZWRvclVzdWFyaW9JZCIsInJldmVuZGVkb3JFcnJvciIsImdldFVzdWFyaW9JZFJldmVuZGVkb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJudW1lcm9QZWRpZG8iLCJNYXRoIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJ0b1VwcGVyQ2FzZSIsInN0YXR1c0luaWNpYWwiLCJjbGllbnRlX2lkIiwibnVtZXJvIiwidmFsb3JfdG90YWwiLCJzdGF0dXNfZGV0YWxoYWRvIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiaXRlbnNQYXJhSW5zZXJpciIsIlByb21pc2UiLCJhbGwiLCJpbmRleCIsInBhY290ZUlkIiwiaXRlbVBhcmFJbnNlcmlyIiwicGFjb3RlX2lkIiwicXRkIiwidmFsb3JfdW5pdGFyaW8iLCJpdGVuc0luc2VyaWRvcyIsImF0dWFsaXphclN0YXR1c1BlZGlkbyIsIm5vdm9TdGF0dXMiLCJkYXRhRXN0aW1hZGEiLCJvYnNlcnZhY29lcyIsInBlZGlkb0F0dWFsIiwiZXJyb3JCdXNjYSIsImRhZG9zQXR1YWxpemFjYW8iLCJkYXRhX2VzdGltYWRhX2VudHJlZ2EiLCJvYnNlcnZhY29lc19yZXZlbmRlZG9yIiwiZGF0YV9lbnRyZWdhX3JlYWwiLCJ1cGRhdGUiLCJnZXRQZWRpZG9zIiwiZ2V0UGVkaWRvc0NsaWVudGUiLCJwZWRpZG9zIiwicGVkaWRvc0Vycm9yIiwiZ2V0VGFtYW5ob3MiLCJnZXRBbHR1cmFzQnlUYW1hbmhvSWQiLCJ0YW1hbmhvSWQiLCJ1bmlxdWVBbHR1cmFzIiwicmVkdWNlIiwiYWNjIiwiY3VycmVudCIsImV4aXN0cyIsImZpbmQiLCJ2YWxvciIsInB1c2giLCJnZXRMYXJndXJhc0J5QWx0dXJhSWQiLCJhbHR1cmFJZCIsInVuaXF1ZUxhcmd1cmFzIiwiZ2V0UGFjb3RlQnlMYXJndXJhSWQiLCJsYXJndXJhSWQiLCJwYWNvdGVBanVzdGFkbyIsImRlc2NyaWNhbyIsImdldENhcnJpbmhvVXN1YXJpbyIsImFkaWNpb25hckl0ZW1DYXJyaW5obyIsImltYWdlbSIsImFkanVzdGVkUXVhbnRpdHkiLCJtYXgiLCJyb3VuZCIsIml0ZW1FeGlzdGVudGUiLCJjb2RlIiwiYXR1YWxpemFyUXVhbnRpZGFkZUNhcnJpbmhvIiwicmVtb3Zlckl0ZW1DYXJyaW5obyIsImxpbXBhckNhcnJpbmhvVXN1YXJpbyIsImF0dWFsaXphckNhcnJpbmhvVXN1YXJpbyIsImdldFJldmVuZGVkb3Jlc0NvbVByb2R1dG8iLCJlc3RvcXVlIiwiZ3QiLCJyZXZlbmRlZG9ySWRzIiwicmV2ZW5kZWRvcmVzIiwicmV2ZW5kZWRvcmVzRXJyb3IiLCJpbiIsInJldmVuZGVkb3IiLCJyIiwiZmlsdGVyIiwic29ydCIsImEiLCJiIiwiZ2V0UmV2ZW5kZWRvcmVzUGFyYVByb2R1dG9zIiwicHJvZHV0b05vbWVzIiwiU2V0IiwicHJvZHV0b3NBZ3J1cGFkb3MiLCJmb3JFYWNoIiwicHJvZHV0b0VzdG9xdWUiLCJwcm9kdXRvIiwiZ2V0VXNlckluZm8iLCJ1c3VhcmlvX2lkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/database.ts\n"));

/***/ })

});